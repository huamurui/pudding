---
const { headings = [] } = Astro.props;
---

<nav class="blog-toc" aria-label="文章目录">
  <ul class="toc-list" id="toc-list">
    {
      headings.map((heading) => (
        <li class={`toc-item toc-item-depth-${heading.depth}`}>
          <a
            href={`#${heading.slug}`}
            class="toc-link"
            data-slug={heading.slug}
          >
            {heading.text}
          </a>
        </li>
      ))
    }
  </ul>
  <div class="toc-indicator" id="toc-indicator"></div>
</nav>

<style>
  .blog-toc {
    position: sticky;
    top: 2rem;
    max-height: calc(100vh - 4rem);
    overflow-y: auto;
    margin-left: 1rem;
    position: relative;
  }

  .toc-list {
    padding: 0.3rem;
    list-style: none;
    border-left: 1px solid var(--border-color);
    margin: 0 0 0 1px;
    position: relative;
  }
  .toc-item {
    margin-bottom: 0.25rem;
    line-height: 1.4;
    position: relative;
    transition: all 0.2s ease;
  }

  .toc-item-depth-2 {
    margin-left: 0.5rem;
  }

  .toc-item-depth-3 {
    margin-left: 1rem;
    font-size: 0.9em;
  }

  .toc-item-depth-4 {
    margin-left: 1.5rem;
    font-size: 0.85em;
  }

  .toc-link {
    color: var(--text-secondary);
    text-decoration: none;
    display: block;
    padding: 0.4rem 0.75rem;
    transition: all 0.2s ease;
    border-radius: 6px;
    position: relative;
    z-index: 2;
  }

  .toc-link:hover {
    color: var(--accent-color);
    background-color: var(--bg-tertiary);
  }

  /* 主活动项样式 */
  .toc-item.active > .toc-link {
    color: var(--accent-color) !important;
    font-weight: 600;
    background-color: color-mix(in srgb, var(--accent-color) 10%, transparent);
  }

  /* 视口内可见项样式 - 合并了原来的secondary-active和in-view */
  .toc-item.visible > .toc-link {
    color: var(--text-primary);
    background-color: color-mix(in srgb, var(--accent-color) 5%, transparent);
  }

  .toc-indicator {
    position: absolute;
    left: 0;
    width: 3px;
    background: linear-gradient(
      to bottom,
      var(--accent-color),
      color-mix(in srgb, var(--accent-color) 70%, transparent)
    );
    border-radius: 2px;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1;
    opacity: 0;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const indicator = document.getElementById("toc-indicator");
    const tocLinks = document.querySelectorAll(".toc-link");

    // 收集所有标题元素
    const headings = Array.from(tocLinks)
      .map((link, index) => {
        const slug = link.getAttribute("data-slug");
        return {
          slug,
          element: document.getElementById(slug),
          link,
          listItem: link.parentElement,
          index,
        };
      })
      .filter((item) => item.element);

    let isProgrammaticScroll = false;
    let activeIndex = -1;
    const visibleHeadings = new Set(); // 存储视口内可见的标题索引

    // 创建IntersectionObserver实例监测可见性
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const heading = headings.find((h) => h.element === entry.target);
          if (!heading) return;

          // 只要有1%可见就视为可见
          if (entry.isIntersecting) {
            visibleHeadings.add(heading.index);
          } else {
            visibleHeadings.delete(heading.index);
          }

          if (!isProgrammaticScroll) {
            updateActiveHeading();
          }
        });
      },
      {
        threshold: 0.01, // 1%可见度即视为可见
        rootMargin: "-10% 0px -10% 0px", // 扩展检测范围
      },
    );

    // 观察所有标题元素
    headings.forEach((heading) => {
      observer.observe(heading.element);
    });

    // 更新活动项和可见项
    function updateActiveHeading() {
      // 重置所有类
      headings.forEach((h) => {
        h.listItem.classList.remove("visible");
      });

      // 获取可见标题并排序
      const visible = Array.from(visibleHeadings).sort((a, b) => a - b);
      let newActiveIndex = -1;

      // 为所有可见标题添加visible类
      visible.forEach((index) => {
        headings[index].listItem.classList.add("visible");
      });

      if (visible.length > 0) {
        // 尝试找到第一个完全可见的标题
        const fullyVisible = visible.find((index) => {
          const rect = headings[index].element.getBoundingClientRect();
          return rect.top >= 0 && rect.bottom <= window.innerHeight;
        });

        if (fullyVisible !== undefined) {
          newActiveIndex = fullyVisible;
        } else {
          // 找到"黄金位置"的标题 - 最接近视口上1/3处
          const viewportThird = window.innerHeight / 3;
          let closestToThird = visible[0];
          let minDistance = Math.abs(
            headings[closestToThird].element.getBoundingClientRect().top -
              viewportThird,
          );

          visible.forEach((index) => {
            const distance = Math.abs(
              headings[index].element.getBoundingClientRect().top -
                viewportThird,
            );
            if (distance < minDistance) {
              minDistance = distance;
              closestToThird = index;
            }
          });

          newActiveIndex = closestToThird;
        }
      } else {
        // 没有可见标题时，找到最近的已滚动过去的标题
        const scrollPosition = window.scrollY;
        const candidates = [...headings]
          .filter((h) => h.element.offsetTop <= scrollPosition + 100) // 加100px缓冲
          .sort((a, b) => b.element.offsetTop - a.element.offsetTop);

        if (candidates.length > 0) {
          newActiveIndex = candidates[0].index;
        } else if (headings.length > 0) {
          // 如果所有标题都在下方，选择第一个
          newActiveIndex = 0;
        }
      }

      // 处理滚动到页面底部的情况
      if (
        window.innerHeight + window.scrollY >=
          document.body.offsetHeight - 100 &&
        headings.length > 0
      ) {
        newActiveIndex = headings.length - 1;
      }

      // 更新活动索引和样式
      if (newActiveIndex !== -1 && newActiveIndex !== activeIndex) {
        activeIndex = newActiveIndex;
        headings.forEach((h) => {
          h.listItem.classList.remove("active");
        });
        // 添加活动类
        if (activeIndex >= 0 && headings[activeIndex]) {
          headings[activeIndex].listItem.classList.add("active");

          // 更新指示器位置
          const activeRect = headings[activeIndex].link.getBoundingClientRect();
          indicator.style.display = "block";
          indicator.style.height = `${activeRect.height}px`;
          indicator.style.top = `${headings[activeIndex].link.parentElement.offsetTop}px`;
          indicator.style.opacity = "1";
        }
      }
    }

    // 平滑滚动到指定标题
    function scrollToHeading(slug) {
      isProgrammaticScroll = true;
      const element = document.getElementById(slug);
      if (element) {
        const headerOffset = 100;
        const elementPosition = element.getBoundingClientRect().top;
        const offsetPosition =
          elementPosition + window.pageYOffset - headerOffset;

        window.scrollTo({
          top: offsetPosition,
          behavior: "smooth",
        });

        // 更新URL hash
        if (window.location.hash !== `#${slug}`) {
          window.history.replaceState(null, "", `#${slug}`);
        }
      }

      // 重置标志
      setTimeout(() => {
        isProgrammaticScroll = false;
        updateActiveHeading();
      }, 200);
    }

    // 初始化
    updateActiveHeading();

    // 监听窗口大小变化
    window.addEventListener("resize", () => {
      if (activeIndex !== -1 && headings[activeIndex]) {
        const activeRect = headings[activeIndex].link.getBoundingClientRect();
        indicator.style.height = `${activeRect.height}px`;
        indicator.style.top = `${headings[activeIndex].link.parentElement.offsetTop}px`;
      }
    });

    // 监听链接点击
    tocLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const slug = link.getAttribute("data-slug");
        scrollToHeading(slug);
      });
    });

    // 初始检查hash
    const initialHash = window.location.hash.substring(1);
    if (initialHash) {
      const element = document.getElementById(initialHash);
      if (element) {
        setTimeout(() => {
          scrollToHeading(initialHash);
        }, 100);
      }
    }
  });
</script>
