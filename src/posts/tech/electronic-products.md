---
icon: edit
date: 2025-11-20
title: 电子产品
---

## 嵌入式

### 芯片能力 与 运行环境

MCU 微控制器 
  - 主频 < 200MHz
  - RAM 几KB到几十KB; Flash：几十KB到几百KB。存储程序代码。
  - 外设：基础的 GPIO、UART、I2C、SPI、ADC。
  - 应用场景：遥控器、电动玩具、智能卡、直流电机控制、LED灯控。
  - STM32F0 esp32-c3

MPU 微处理器 
  - 主频 < 500MHz
  - RAM：64KB 到 512KB，足以运行FreeRTOS和多个任务栈、网络协议栈；Flash：512KB 到 2MB。可以存储复杂的应用程序和文件系统。
  - 外设：更丰富的串口、CAN总线、USB、以太网MAC、加密加速器。
  - 应用场景：智能家居设备（插座、传感器）、可穿戴设备、工业PLC、无人机飞控、复杂的电机驱动（FOC）。
  - STM32F4 ESP32-S3

不那么微的处理器  
 - 500MHz 到 1.5GHz+ 到这里和普通手机电脑性能差距可能都不算很大了。
 - RAM：512KB 到 1GB+。通常需要外接DDR内存。
 - Flash：内部Flash可能不大，但支持外部eMMC、SD卡，存储空间以GB计。
 - 外设：支持LCD显示器、摄像头、千兆以太网、高速USB等。
 - 应用场景：智能家居中控屏、工业 HMI、网络网关、广告机、视频播放器。
 - 树莓派/各种派

再就是，现在的手机电脑， 
  - 频率 2-4GHz
  - ...

更强大的，自动驾驶、机器人、高端医疗影像、5G基站。... 感觉和个人没什么关系了。


芯片另一个重要特征也许是，指令集，架构
risc/cisc
具体的 x86/arm/risc-v/pfga...

#### 裸机, RTOS, TSOS(Linux/Android...)

现在手机电脑上的系统，都属于分时操作系统。这个名字描述的特征是，使用时间片轮转等等调度方式允许多个，很多很多个程序同时保持运行，进行任务调度的目标是高平均吞吐量和公平性。  
而实时操作系统通常会追求确定性——通常会要求确定某个任务能在一定时间内完成，为此可以不在乎整体的平均吞吐量，完全基于优先级进行任务调度。

rtos 相对 linux 这种操作系统功能更加专一，会用在一些要求严格的关键任务控制上。  
而 linux 这种操作系统会被用来做功能更多，更复杂，但没有硬性响应要求的东西上。比如带操作界面的东西，比如手机电脑。  

而裸机，它通常运行在很简单的芯片，很简单的电路板上，处理很简单的事情。它可以有着更快的响应速度，更简单可控更稳定的行为，更少的能耗，当然还更便宜。
而相对而言，使用 rtos 其实意味着，这个东西还是需要处理多任务情况的。

#### 通信外设 communication peripheral
- GPIO
  - General-purpose input/output, 最基础的信号输入输出
- ADC, DAC 
  - ADC (Analog-to-Digital Converter) and DAC (Digital-to-Analog Converter), 模拟信号转数字信号，数字信号转模拟信号。adc 传感器数据读取，dac 将信息转为模拟信号比如电压。
- UART, I2C, SPI
  - I2C
    - 同步、半双工、多主多从。两根线（SDA数据线，SCL时钟线）。
  - SPI
    - 同步、全双工、高速。通常需要四根线：MOSI MISO SCLK CS/SS
  - UART ... 只是烧录时看到要这个
- CAN 
  - Controller Area Network 控制器局域网
  - 汽车和工业环境而生的“硬汉”协议。
- USB 
  - Universal Serial Bus 通用串行总线
  - 消费电子和通用计算设计的“全能型”协议。

### esp32

esp32 是一个芯片系列，似乎有时候也可以是系列的系列名。特点是不错的性能带 wifi 蓝牙.  
有一个开发框架叫做  ESP-IDF ，这个框架是基于 free-rtos 这个操作系统做的，包含了各种库与编译烧录调试等一系列工具链。

- 环境搭建
- ESP-IDF  与 free-rtos
- 硬件与外设
- 物联网，wifi，tcp/ip/http

esp32-c3
esp32-c3 是另一个芯片系列，或型号
- risc-v 32-bit, 160Mhz
- 4 MB flash
- wifi(802.11/b/g/n(wifi1,3,4)), bluetooth 5

esp32-s3
esp32-s3 是又另一个芯片系列，或型号
- dual-core 32-bit, 240Mhz
- wifi(802.11/b/g/n(wifi1,3,4)), bluetooth 5


嗯...有点，不知道说什么的感觉。  
好多小玩具我问问 deepseek，把代码粘贴过来，在 vscode  ESP-IDF  的插件里点点点，就能装依赖构建烧录监控了...  

我既没有了解更底层更硬件的东西，也没有去看那个 rtos 系统。  
可能更多的看到的是各种设备要接什么线，
- 一个小 led 灯只要最简单的 gpio, 还有 ws2812 这种神奇的东西，一个线就能控制一大个灯板. 
- 摇杆可能要用带 adc 的引脚
- 一个小的显示屏需要 I2C 的 SCL 和 SDA
- 以及这个小板板还带 wifi, 可以自己做 wifi 信号源，或者把wifi信息写进代码连接别的 wifi 后，启动一个小 web 服务器，全程... 也是调  ESP-IDF  的包。感觉，之前买的相机 wifi 连接就是前者。
......

<details>
<summary>
deepseek 老师快帮帮我
</summary>

你提到的这种“不知道说什么的感觉”，其实恰恰是每个从软件世界踏入硬件世界的开发者都会经历的阶段——**理论与实践之间的那道鸿沟**。

你已经用ESP32点过灯、驱动过外设、甚至玩转了Wi-Fi Web服务器，这已经超越了90%的纸上谈兵者。现在，让我们来帮你把这段经历“升华”一下，看看你具体学到了什么，以及下一步可以窥探哪些更深处的东西。

0. 你实践中的“无形”收获

当你成功让代码在板子上运行时，你其实已经在不知不觉中掌握了几个至关重要的概念：

- **硬件抽象层**：你调用 `gpio_set_level` 时，没直接操作寄存器， ESP-IDF 帮你屏蔽了底层硬件差异。这就是HAL的意义——让开发者专注于业务逻辑。
-  **库与框架的威力**：你用几行代码就启动了Web服务器，这背后是 ESP-IDF 集成了LwIP这个轻量级TCP/IP协议栈。在嵌入式领域，**站在巨人的肩膀上（使用成熟的库和RTOS）是项目成功的关键**。
-  **事件驱动编程**：虽然你没直接写事件循环，但Wi-Fi连接成功、获取到IP地址，这些都是在触发事件，你的代码在响应这些事件。这是嵌入式GUI和网络应用的核心模式。

从“调包侠”到“明白人”：可以窥探的下一步

你觉得只是在调用API，这是因为 ESP-IDF 设计得太好了。想更深入？可以从这里下手：

1. 掀开RTOS的窗帘看一眼
你不需要从头写一个调度器，但可以**在调试时打开FreeRTOS的监视功能**。
- 在 `menuconfig` 中启用 `FreeRTOS -> Enable FreeRTOS trace hooks` 和 `Enable event trace`。
- 烧录运行后，输入 `idf.py monitor`，然后按 `Ctrl+T` 再按 `C`，可以**列出所有任务的状态（Running, Blocked, Ready）**。
- 你会亲眼看到，当你访问Web服务器时，网络处理任务从 `Blocked` 变为 `Running`，你的主任务可能正 `Blocked` 在 `vTaskDelay` 上。**这一刻，多任务并发的概念就从书本变成了你眼前的现实。**

2. 解剖一个外设的驱动
以你用的I2C屏幕为例，别停留在“接线然后调用`i2c_master_write`”这个层面。
- 去 ESP-IDF 的GitHub仓库，找到 `/components/driver/i2c.c` 这个文件。
- 粗略地看一眼 `i2c_master_write` 这个函数（不用全看懂）。你会发现，它最终是在操作一系列名为 `I2C0` 或 `I2C1` 的**存储器**（即外设寄存器）。
- 这时，你再搜一下 **《ESP32-C3 Technical Reference Manual》**，找到I2C控制器章节，你会看到这些寄存器的描述。你会恍然大悟：“哦，原来`i2c_master_write`里写这个魔数，是为了配置时钟频率；写那个寄存器，是为了填充要发送的数据。”
- **这个过程，就是你从“调包”到“理解硬件如何被驱动”的关键一步。**

3. 挑战“底层”的乐趣 - 点灯的另一重境界
你用过WS2812，它是个用单线特殊时序的协议。 ESP-IDF 有它的库。但你想过吗？这个“特殊时序”是怎么产生的？
- 尝试不用库，**用纯粹的`gpio_set_level`和`esp_rom_delay_us`来模拟WS2812的0码和1码**（比如，高电平0.4us后拉低是0，高电平0.8us后拉低是1）。
- 你会发现很难调准，因为函数调用本身有开销。这时你就会理解，为什么数据手册里经常提到**精确延时需要靠定时器甚至CPU汇编指令**。
- 这个失败的经历，比成功点亮它更有价值，因为它让你直面了软件控制硬件的**时序精度**这个核心问题。

4. 连接你已有的知识体系

你提到的“手机电脑是分时，嵌入式有实时”，这个理解完全正确。现在可以把这个概念和你的ESP32项目联系起来：
- 你的Web服务器项目里，**网络协议栈处理、等待HTTP请求**这些不紧急的任务，优先级可以设低一点。
- 如果同时有一个任务需要**精确读取传感器数据**，它的优先级就应该设高，并且它应该能够**抢占**那个网络任务。
- 你在代码中配置任务优先级时，就是在实践和验证**实时调度**的理论。

</details>

### rv1106

rv1106g3 是瑞芯微的一款芯片, 
- Cortex A7 1.2GHz
- 1 tops npu
luckfox pico zero 是使用这款芯片的一个开发版
- 2.4GHz WiFi6 Bluetooth 5.2/BLE
- 256MB DDR3L, eMMC(8GB)
- ...

> 一些, 也许不太相关的事。  
> 在裸机和 rtos 中, 一般不会连接很复杂的设备(比如高分辨率屏幕摄像头一类的), 那些简单元件只要设置一下引脚, 引一下基本的库就可以连接, 驱动.
> 而...  我才知道... arm Linux 上会有设备树这种东西, 一些复杂设备不是插上去就能用的。在没有像 x86 的各种硬件层约定和 bios, 也不合适使用太应用层的像 USB 协议这种东西的地方, 设备并不是能直接连接的, 在这里, 没有那么多一定如何的共识.  缺少共识规范带来了困难, 也带来了更多自由, mipi dsi csi 会比 usb 更可定制, 更高效节能. 但, 这些也不可避免的带来了更多的适配工作, 这些奇奇怪怪的芯片和设备, 可能要一个芯片要对一个个设备一个个的写一大片驱动然后配置设备树才能连接, 使用...  
> 同时, 生产这种规格芯片的厂商, 也都...  高通, 联发科, 华为, 瑞芯微, 全志等等这些芯片厂商, 基本都闭源, 资料不公开...  即使是装系统, 也并不是随便找一个就能刷上去用.. 很多时候都是需要厂商提供一个特定版本的 Linux/Andriod 系统。这些复杂的缺少说明的芯片对个人而言, 很难去做太多从头开始的开发。  
> 但... 不管怎么样, 这些芯片做的东西, 个人也许多少还能找找开发板搀和一下弄弄小玩具, 像 intel amd nvdia 这些巨无霸们做的巨无霸芯片, 我能想到的基本都是电脑, 服务器, 还有各种计算中心会用.  
>
> 编译, 交叉编译, 烧录, 链接, fork进程, 进程通信, 调度...  
> 我好像回忆起了操作系统课上..., 复制粘贴的例程和实验报告...  虽然, 估计只是想起了几个词...  
> 那时候,我好像还什么都不知道, 到处摸摸, 但一点小问题都要查好久那种, 还在画画, 看哲学书...  


### other...

n100
i5 12490f
snapdragon 8gen2
......


