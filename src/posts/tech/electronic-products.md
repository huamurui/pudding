---
icon: edit
date: 2025-11-20
title: 电子产品
tags: ['电子产品']

---

好想，到处摸摸

# 消费电子

## 嵌入式

### 芯片能力 与 运行环境

#### 规格

MCU 微控制器 
  - 主频 < 200MHz
  - RAM 几KB到几十KB; Flash：几十KB到几百KB。存储程序代码。
  - 外设：基础的 GPIO、UART、I2C、SPI、ADC。
  - 应用场景：遥控器、电动玩具、智能卡、直流电机控制、LED灯控。
  - 51 STM32F0 esp32-c3

MPU 微处理器 
  - 主频 < 500MHz
  - RAM：64KB 到 512KB，足以运行FreeRTOS和多个任务栈、网络协议栈；Flash：512KB 到 2MB。可以存储复杂的应用程序和文件系统。
  - 外设：更丰富的串口、CAN总线、USB、以太网MAC、加密加速器。
  - 应用场景：智能家居设备（插座、传感器）、可穿戴设备、工业PLC、无人机飞控、复杂的电机驱动（FOC）。
  - STM32F4 ESP32-S3

不那么微的处理器  
 - 500MHz 到 1.5GHz+ 到这里和普通手机电脑性能差距可能都不算很大了。
 - RAM：512KB 到 1GB+。也许 DDR 内存。
 - Flash：内部Flash可能不大，但支持外部eMMC、SD卡，存储空间以GB计。
 - 外设：支持LCD显示器、摄像头、千兆以太网、高速USB等。
 - 应用场景：智能家居中控屏、工业 HMI、网络网关、广告机、视频播放器。
 - 树莓派/各种派

再就是，现在的手机电脑， 
  - 频率 2-4GHz
  - ...

更强大的，自动驾驶、机器人、高端医疗影像、5G基站。... 感觉和个人没什么关系了。


芯片另一个重要特征也许是，指令集，架构
risc/cisc
具体的 x86/arm/risc-v...

可能是另一些比较奇怪的东西
pfga asic


#### 裸机, RTOS, TSOS(Linux/Android...)

现在手机电脑上的系统，都属于分时操作系统。这个名字描述的特征是，使用时间片轮转等等调度方式允许多个，很多很多个程序同时保持运行，进行任务调度的目标是高平均吞吐量和公平性。  
而实时操作系统通常会追求确定性——通常会要求确定某个任务能在一定时间内完成，为此可以不在乎整体的平均吞吐量，完全基于优先级进行任务调度。

rtos 相对 linux 这种操作系统功能更加专一，会用在一些要求严格的关键任务控制上。  
而 linux 这种操作系统会被用来做功能更多，更复杂，但没有硬性响应要求的东西上。比如带操作界面的东西，比如手机电脑。  

而裸机，它通常运行在很简单的芯片，很简单的电路板上，处理很简单的事情。它可以有着更快的响应速度，更简单可控更稳定的行为，更少的能耗，当然还更便宜。
而相对而言，使用 rtos 其实意味着，这个东西还是需要处理多任务情况的。

##### 一个，小例子

关于为什么要有操作系统。  
操作系统最开始，是不是也是一些很零散的函数堆在一起...  

有一个关于在一个cpu上，同时控制两个led，一个0.4秒亮0.4秒暗，一个0.3秒亮0.3秒灭。  
要写程序，如果硬写也可以根据最大公因数写循环然后看是不是整除段去写，但程序会很难看。  

而如果有操作系统，我们就可以单独的写两段代码，看起来这两段代码可以并行着，同时的随时能够使用同一个 cpu，但实际上是操作系统的调度给了每个程序似乎都可以完全拥有硬件的虚拟。中断，让硬件可以偷偷逃跑去做别的，而计算速度极快的处理器即使中断也可以立马回来接住原来的事。  
上面提到的例子做些扩展，即使在嵌入式可能也会有需要一个处理器连接多个传感器控制器去做数据的收发处理，这时候 rtos 就会是很好的帮助。  

### 通信外设 communication peripheral

- 通信外设可能也算一种资源了，而且对于一些逻辑不复杂，性能需求不强，但小功能比较多的小玩具，芯片的通信外设可能是很优先要看的东西。

- GPIO，ADC, DAC
  - General-purpose input/output, 最基础的信号输入输出
  - ADC (Analog-to-Digital Converter) and DAC (Digital-to-Analog Converter), 模拟信号转数字信号，数字信号转模拟信号。adc 传感器数据读取，dac 将数字信号转为模拟信号比如电压。
- UART, I2C, SPI
  - 上面的如果只是引脚，这里可能就算是通信协议了，这些协议可能可以算作物理层，以及一小部分链路层的东西。基础串行协议。
  - UART  
    - Universal Asynchronous Receiver/Transmitter 一开始是在烧录时看到要这个  
    - 这也许是最基础的的通信协议，也被称为串口，除了 gnd vcc, 有两根数据传输线 rx tx，对称连接，一方的发送线插到另一方的接收线上。全双工，但只能两个之间相连。
    - 没有时钟线，所以叫异步，需要提前约定收发频率进行通信。
    - 115.2 - 921.6kbps
  - I2C 
    - Inter-Integrated Circuit
    - 同步、半双工、多主多从。两根线（SDA数据线，SCL时钟线）。
    - 这里提到了时钟，时钟线一般意味着有主从这样的区分，发送信息的一方同时要提供时钟信号，是主，另一面是从。
    - 半双工是只有一条数据线不是双车道； 多主多从, 应该是在讲总线这个概念，一条线上可以连多个设备，一个主提供信号，然后每次通信的数据其实是，主设备发一串 req: （开始信号+地址+R/T+具体信息），然后从设备应答 res ，如果有回传信息也根据主设备时钟回传。
    - 关于总线，一个场景是，一个 i2c 上连了一堆传感器，处理器隔一段时间扫一遍拿一遍数据。
    - 100 - 400kbps
  - SPI
    - 同步、全双工、高速。通常需要四根线：MOSI MISO SCLK CS/SS(Chip Select / Slave Select)
    - SPI 有时钟线，有主从，它是怎么全双工的呢? - 主设备发送命令去让从设备发送信息然后读取，时间信号也还是主设备提供(感觉控制欲好强)，而多出的 CS/CC 则像一个专门的指挥棒或点名器，一次选一个从设备通信，让一堆从设备不会挤占 MOSI MISO。
    - 50 - 100+ Mbps
  - 其他
    - SPI 比上两个流量大，一个是两条数据线比 i2c 强，一个是带时钟线频率可以更高比 uart 强。一些分辨率不是太高的屏幕，还有 sd 卡会用到 SPI。
    - 但，时钟线的存在可能也限制了 spi 和 i2c 的传输距离，它们只能是板内、短距离通信。而长距离通信几乎只能是异步的，或者就是要把时间与数据线合并，使用特殊的数据组织去实现时间线的功能。
    - 另外 UART 只是普通版本，ttl 传输，它也可以通过加装特别的数据处理芯片，变成差分数据传输，传输距离与速度会多很多很多。
- mipi dsi/csi
  - 这可能是种，和 usb 一样完整复杂，但只为高速大量数据流传输而生的东西， usb 想要什么都能往上连，而它连接设备几乎就是，屏幕, 摄像头短距连接。
- USB 
  - Universal Serial Bus 通用串行总线 消费电子和通用计算设计的“全能型”协议。
  - 嗯...  usb 数据传输协议; usb 接口的物理形状， Type-A、Type-B、Type-C、miniUSB、microUSB...;  差分信号，时钟恢复...;Thunderbolt...
  - 数据帧、寻址、错误检测
  - 端到端连接、流量控制
  - 连接状态、会话
  - 设备发现，定义
  - 这几乎是一个完整的计算机网络模型了。 usb 包括下面这堆，这里容易看到的更多好像只是使用上的...更具体的东西...反正不是几句话能写完的
- PCIe，M.2 / NVMe

- CAN 
  - Controller Area Network 控制器局域网
  - 汽车和工业环境而生的“硬汉”协议。

- wifi
- bluetooth
- Ethernet
  - mqtt 
    - 为物联网而生的专业消息协议
    - mqtt vs http
      - req-res | pub-sub

### 具体的
#### esp32

esp32 是一个芯片系列，似乎有时候也可以是系列的系列名。特点是不错的性能带 wifi 蓝牙.  
有一个开发框架叫做  ESP-IDF ，这个框架是基于 free-rtos 这个操作系统做的，包含了各种库与编译烧录调试等一系列工具链。

- 环境搭建
- ESP-IDF  与 free-rtos
- 硬件与外设
- 物联网，wifi，tcp/ip/http

esp32-c3
esp32-c3 是另一个芯片系列，或型号
- risc-v 32-bit, 160Mhz
- 4 MB flash
- wifi(802.11/b/g/n(wifi1,3,4)), bluetooth 5

esp32-s3
esp32-s3 是又另一个芯片系列，或型号
- dual-core 32-bit, 240Mhz
- wifi(802.11/b/g/n(wifi1,3,4)), bluetooth 5


嗯...有点，不知道说什么的感觉。  
好多小玩具我问问 deepseek，把代码粘贴过来，在 vscode  ESP-IDF  的插件里点点点，就能装依赖构建烧录监控了...  

我既没有了解更底层更硬件的东西，也没有去看那个 rtos 系统。  
可能更多的看到的是各种设备要接什么线，
- 一个小 led 灯只要最简单的 gpio, 还有 ws2812 这种神奇的东西，一个线就能控制一大个灯板. 
- 摇杆可能要用带 adc 的引脚
- 一个小的显示屏需要 I2C 的 SCL 和 SDA
- 以及这个小板板还带 wifi, 可以自己做 wifi 信号源，或者把 wifi 信息写进代码连接别的 wifi 后，启动一个小 web 服务器，全程... 也是调  ESP-IDF  的包。感觉，之前买的相机 wifi 连接就是前者。
......

<details>
<summary>
呜呜呜 deepseek 老师快帮帮我
</summary>

你提到的这种“不知道说什么的感觉”，其实恰恰是每个从软件世界踏入硬件世界的开发者都会经历的阶段——**理论与实践之间的那道鸿沟**。

你已经用ESP32点过灯、驱动过外设、甚至玩转了Wi-Fi Web服务器，这已经超越了90%的纸上谈兵者。现在，让我们来帮你把这段经历“升华”一下，看看你具体学到了什么，以及下一步可以窥探哪些更深处的东西。

0. 你实践中的“无形”收获

当你成功让代码在板子上运行时，你其实已经在不知不觉中掌握了几个至关重要的概念：

- **硬件抽象层**：你调用 `gpio_set_level` 时，没直接操作寄存器， ESP-IDF 帮你屏蔽了底层硬件差异。这就是HAL的意义——让开发者专注于业务逻辑。
-  **库与框架的威力**：你用几行代码就启动了Web服务器，这背后是 ESP-IDF 集成了LwIP这个轻量级TCP/IP协议栈。在嵌入式领域，**站在巨人的肩膀上（使用成熟的库和RTOS）是项目成功的关键**。
-  **事件驱动编程**：虽然你没直接写事件循环，但Wi-Fi连接成功、获取到IP地址，这些都是在触发事件，你的代码在响应这些事件。这是嵌入式GUI和网络应用的核心模式。

从“调包侠”到“明白人”：可以窥探的下一步

你觉得只是在调用API，这是因为 ESP-IDF 设计得太好了。想更深入？可以从这里下手：

1. 掀开RTOS的窗帘看一眼
你不需要从头写一个调度器，但可以**在调试时打开FreeRTOS的监视功能**。
- 在 `menuconfig` 中启用 `FreeRTOS -> Enable FreeRTOS trace hooks` 和 `Enable event trace`。
- 烧录运行后，输入 `idf.py monitor`，然后按 `Ctrl+T` 再按 `C`，可以**列出所有任务的状态（Running, Blocked, Ready）**。
- 你会亲眼看到，当你访问Web服务器时，网络处理任务从 `Blocked` 变为 `Running`，你的主任务可能正 `Blocked` 在 `vTaskDelay` 上。**这一刻，多任务并发的概念就从书本变成了你眼前的现实。**

2. 解剖一个外设的驱动
以你用的I2C屏幕为例，别停留在“接线然后调用`i2c_master_write`”这个层面。
- 去 ESP-IDF 的GitHub仓库，找到 `/components/driver/i2c.c` 这个文件。
- 粗略地看一眼 `i2c_master_write` 这个函数（不用全看懂）。你会发现，它最终是在操作一系列名为 `I2C0` 或 `I2C1` 的**存储器**（即外设寄存器）。
- 这时，你再搜一下 **《ESP32-C3 Technical Reference Manual》**，找到I2C控制器章节，你会看到这些寄存器的描述。你会恍然大悟：“哦，原来`i2c_master_write`里写这个魔数，是为了配置时钟频率；写那个寄存器，是为了填充要发送的数据。”
- **这个过程，就是你从“调包”到“理解硬件如何被驱动”的关键一步。**

3. 挑战“底层”的乐趣 - 点灯的另一重境界
你用过WS2812，它是个用单线特殊时序的协议。 ESP-IDF 有它的库。但你想过吗？这个“特殊时序”是怎么产生的？
- 尝试不用库，**用纯粹的`gpio_set_level`和`esp_rom_delay_us`来模拟WS2812的0码和1码**（比如，高电平0.4us后拉低是0，高电平0.8us后拉低是1）。
- 你会发现很难调准，因为函数调用本身有开销。这时你就会理解，为什么数据手册里经常提到**精确延时需要靠定时器甚至CPU汇编指令**。
- 这个失败的经历，比成功点亮它更有价值，因为它让你直面了软件控制硬件的**时序精度**这个核心问题。

4. 连接你已有的知识体系

你提到的“手机电脑是分时，嵌入式有实时”，这个理解完全正确。现在可以把这个概念和你的ESP32项目联系起来：
- 你的Web服务器项目里，**网络协议栈处理、等待HTTP请求**这些不紧急的任务，优先级可以设低一点。
- 如果同时有一个任务需要**精确读取传感器数据**，它的优先级就应该设高，并且它应该能够**抢占**那个网络任务。
- 你在代码中配置任务优先级时，就是在实践和验证**实时调度**的理论。

</details>

#### rv1106

rv1106g3 是瑞芯微的一款芯片, 
- Cortex A7 1.2GHz
- 1 tops npu  

luckfox pico zero 是使用这款芯片的一个开发版
- 2.4GHz WiFi6 Bluetooth 5.2/BLE
- 256MB DDR3L, eMMC(8GB)
- ...

0.  
luckfox 的 sdk 和 交叉编译工具都只能在 ubuntu 上运行，所以，如果电脑系统不是 ubuntu，要装虚拟机或者 docker 一类，然后用网口 ssh 登陆等等等等...  
但，我直接在 ubuntu 上开发了，我买的这个小板板也没有网口x，不这样估计会很麻烦。就...  也许不太一样。  
电脑是 n100 小主机，前些天编译 sdk 记了一下大概要两个小时x，不过改小配置单独编译内核时好像不到一分钟就好了...我怀疑它根本就没动弹...  
开发板 type-c 连接后 adb shell 登陆就能看到开发板的系统了。  

看看系统配置，看看 cpu，内存，然后做的第一件事可能是连 wifi 然后用 wget 看网页 html x。  

这里面还带了 python，from periphery import GPIO 这个包也是直接有的，所以可以直接在开发板上写一些控制引脚的输入输出的小东西。  
不过 pip 还是木大。不然 ~   

1.  
再然后，我在尝试驱动一个 i2c 接口的小屏幕...  

我在 sdk 里找到了屏幕芯片的驱动文件，但...  改了几个 config 文件，编译烧录后，最后似乎也没找到驱动弄没弄进去。
然后尝试直接连接 i2c，发现 i2c-3 引脚默认好像是关的，用它们的配置工具打开一下, 还有一个引脚定义上不存在的i2c-4... 似乎是专门给 dsi 摄像头的。
然后交叉编译 c 文件 adb push 到开发板测试...  

hello word 可以，但 i2c 屏幕感觉有问题一会亮一会不亮而且通信速度好慢怀疑屏幕或者接线或者~~我~~ ai 写的代码有问题阿巴阿巴  
再但是买了个小喇叭加上板板自带的麦克风试了试录音和播放，效果还可以，而且 Linux 上工具好多x
ffmpeg 

2. 
啊

> 一些, 也许不太相关的事。  
> 在裸机和 rtos 中, 一般不会连接很复杂的设备(比如高分辨率屏幕摄像头一类的), 那些简单元件只要设置一下引脚, 引一下基本的库就可以连接, 驱动.  
> 而...  我才知道... arm Linux 上会有设备树这种东西, 一些复杂设备不是插上去就能用的。在没有像 x86 的各种硬件层约定和 bios, 也不合适使用太应用层的像 USB 协议这种东西的地方, 设备并不是能直接连接的, 在这里, 没有那么多一定如何的共识.  缺少共识规范带来了困难, 也带来了更多自由, mipi dsi csi 会比 usb 更可定制, 更高效节能. 但, 这些也带来了更多的适配工作, 这些奇奇怪怪的芯片和设备, 可能要一个芯片要对一个个设备一个个的写一大片驱动然后配置设备树才能连接, 使用...  但, 驱动设备树一类的东西, 再怎么讲也是组织这些复杂设备的一种方式, 复杂不会消失, usb 大概, 也只是把复杂更多的放到了协议中...
> 还有一件事是, 生产这种规格芯片的厂商, 也都...  高通, 联发科, 华为, 瑞芯微, 全志等等这些芯片厂商, 基本都闭源, 资料不公开...  即使是装系统, 也并不是随便找一个就能刷上去用.. 很多时候都是需要厂商提供一个特定版本的 Linux/Android 系统。而且这种复杂芯片的资料...可能给了也不是个人能处理的了的。总之这些复杂的缺少说明的芯片对个人而言, 很难去做太多从头开始的开发。  
> 但... 不管怎么样, 这些芯片做的东西, 个人也许多少还能找找开发板搀和一下弄弄小玩具, 像 intel amd nvdia 这些巨无霸们做的巨无霸芯片, 我能想到的就是 ||fuck nvdia|| 电脑, 服务器, 还有各种计算中心会用.  
>
> 编译, 交叉编译, 烧录, 链接, fork 进程, 进程通信, 调度...  
> 我好像回忆起了操作系统课上..., 复制粘贴的例程和实验报告...  虽然, 估计只是想起了几个词...  
> 那时候,我好像还什么都不知道, 到处摸摸, 但一点小问题都要查好久那种, 还在画画, 看哲学书...  

#### 一些, 小玩具

- led 灯板
  - ws2812
- joy-stick
  - adc
- 电机:
  - 步进/伺服电机/舵机
    - 基础的运动原理和结构上 步进/伺服 可能相似，它们可以直接精密控制磁场来控制转动，但伺服电机是指多了许多反馈传感器所以会更加精准稳定。
    - 而舵机似乎是指那种普通的无刷/有刷电机经过齿轮减速后加上比较有限的反馈传感器做的。或者换种角度，有种叫做编码器的东西，机械/光/磁的都有，用它监控电机转动加上小控制器就可以让普通电机组成舵机，实现一些精密的操作，重要的是，如果要求不高，这样有做的很小的方案，而伺服电机几乎没多少小东西。
  - 其他特别的
    - 微型空心杯电机——无人机常用
    - 线性谐振马达——模拟各种震动反馈
- 姿态, 加速度传感器
  - 大致，分两种。一种输出原始数据，一种可以硬件解码一类的输出一定除噪防抖预处理后的数据。是不是稍微复杂些的传感器都会这么分...
- 显示器
  - 基本接口
  - 驱动芯片，触摸芯片
- 摄像头
  - ..
- 其他
  - 充放电模块，电池...

>也许可以粗暴的分成输入输出两类，传感器和显示器。  
>会涉及大量数据处理的，似乎主要都还是视觉相关的——摄像头和屏幕。  
>  
>其实会想起来，机器性能够了之后做的第一件事就是做屏幕，让人能看到可以交互的界面。  
>然后前端和移动互联网的发展除了让更多人体验科技的乐趣，也让入门编程这件事变得更加...简单？总之视觉的反馈总是更明显更容易接受一些。  
>>海量的前端程序员重塑了开源生态 ES5: 2009, react.js: 2013, vscode: 2015, ...  
>>“编程” 不再是少部分 geek 的特权.  || 但，学校 java 课上 javaX 做界面还是就是在吃屎 ||


#### other...

n100
i5 12490f
snapdragon 8gen2
......


### 操作系统

有关，软硬件发展史

抽象一点。  
管理资源, 为程序提供服务的程序。系统

具体一点。  
管理硬件，为软件提供服务。硬件输出到软件，软件输出到硬件。操作系统。


程序是状态机的静态描述
  - 描述了所有可能的程序状态
  - 程序 (动态) 运行起来，就成了进程 (进行中的程序)

操作系统 = 状态机的管理者
  - 进程管理 = 状态机管理

一个直观的想法
  - 创建状态机：spawn(path, argv)
  - 销毁状态机: _exit()
      - 这是一个合理的设计 (例子：Windows)
UNIX 的答案
    复制状态机: fork()
    复位状态机: execve()


## 数电模电

数电
  - 时钟驱动的状态机(寄存器/内存/...)
  - 设计，复杂性控制
  - 公理系统

模电
  - “感知”和“翻译”现实世界，“放大”和“塑造”这些信号
  - 现实与数字的桥梁

嗯...这些想要搞清楚，也许，要花好多好多。  
我只是想，摸摸。  

ne555,
运放


